# DistributedKV 项目学习手册

## 目录
- [1. 项目愿景](#1-项目愿景)
- [2. 核心架构：LSM-Tree 存储策略](#2-核心架构lsm-tree-存储策略)
    - [2.1 什么是 LSM-Tree？](#21-什么是-lsm-tree)
    - [2.2 为什么选择 LSM-Tree？](#22-为什么选择-lsm-tree)
- [3. 内存组件：MemTable 与跳表](#3-内存组件memtable-与跳表)
    - [3.1 MemTable 的作用](#31-memtable-的作用)
    - [3.2 为什么用跳表 (SkipList) 实现？](#32-为什么用跳表-skiplist-实现)
    - [3.3 跳表的基本原理](#33-跳表的基本原理)
    - [3.4 跳表核心操作图解](#34-跳表核心操作图解)
        - [3.4.1 结构总览](#341-结构总览)
        - [3.4.2 插入操作详解 (以插入 Key=8 为例)](#342-插入操作详解-以插入-key8-为例)
        - [3.4.3 复杂度分析](#343-复杂度分析)
        - [3.4.4 查找操作详解 (Search)](#344-查找操作详解-search)
        - [3.4.5 Search 的复杂度与工程注意事项](#345-search-的复杂度与工程注意事项)
        - [3.4.6 删除操作详解 (Remove)](#346-删除操作详解-remove)
        - [3.4.7 Remove 的时空复杂度与工程注意事项](#347-remove-的时空复杂度与工程注意事项)
    - [3.5 跳表单元测试（insert/search/remove）](#35-跳表单元测试insertsearchremove)
- [4. 分布式共识：Raft 协议](#4-分布式共识raft-协议)
- [5. 现代 C++ 内存管理：智能指针与 RAII](#5-现代-c-内存管理智能指针与-raii)
    - [5.1 什么是 RAII？](#51-什么是-raii)
    - [5.2 三大智能指针详解](#52-三大智能指针详解)
    - [5.3 决策指南：该选哪种？](#53-决策指南该选哪种)
    - [5.4 现代 C++：std::optional 与 std::nullopt](#54-现代-cstdoptional-与-stdnullopt)
    - [5.5 C++17：结构化绑定（Structured Bindings）](#55-c17结构化绑定structured-bindings)
- [6. 构建系统与 CMake](#6-构建系统与-cmake)
    - [6.1 CMake 是什么？](#61-cmake-是什么)
    - [6.2 本项目的构建现状](#62-本项目的构建现状)
    - [6.3 是否有比 CMake 更高级的？](#63-是否有比-cmake-更高级的)
    - [6.4 该用哪种构建系统？](#64-该用哪种构建系统)
- [7. 编码规范与文档化](#7-编码规范与文档化)
- [8. 学习路径建议](#8-学习路径建议)
- [9. 关键术语表](#9-关键术语表)
- [10. 项目计划（周级细化）](#10-项目计划周级细化)
    - [10.1 阶段 A：单机存储引擎（第 1–6 周）](#101-阶段-a单机存储引擎第-16-周)
    - [10.2 阶段 B：Raft 共识协议（第 7–12 周）](#102-阶段-braft-共识协议第-712-周)
    - [10.3 阶段 C：网络层与集成（第 13–16 周）](#103-阶段-c网络层与集成第-1316-周)
    - [10.4 阶段 D：工程化与展示（第 17–20 周）](#104-阶段-d工程化与展示第-1720-周)
    - [10.5 每周投入建议](#105-每周投入建议)
- [11. 测试与验证（GTest/CTest）](#11-测试与验证gtestctest)
    - [11.1 单元测试解决什么问题](#111-单元测试解决什么问题)
    - [11.2 本项目的测试入口](#112-本项目的测试入口)
    - [11.3 ASSERT 与 EXPECT 如何选择](#113-assert-与-expect-如何选择)
    - [11.4 常用断言速查](#114-常用断言速查)
    - [11.5 写测试的 AAA 套路](#115-写测试的-aaa-套路)
    - [11.6 让测试可复现](#116-让测试可复现)

---

## 1. 项目愿景与分布式系统基础

### 1.1 什么是分布式系统？
简单来说，分布式系统就是**一群独立的计算机，通过网络相互通信，并向用户表现得像一台单一的计算机一样**。

**核心特征：**
- **网络通信**：节点之间不共享内存，只能通过消息传递。
- **并发性**：多个节点同时运行。
- **缺乏全局时钟**：很难确定事件发生的绝对先后顺序。
- **部分故障**：集群中的某些节点可能挂掉或断网，但整个系统必须继续运行。

**为什么我们要搞分布式 KV？**
单机存储总有上限（磁盘容量、处理能力）。通过分布式，我们可以实现：
- **可扩展性 (Scalability)**：加机器就能存更多数据。
- **容错性 (Fault Tolerance)**：一台机器坏了，数据不丢，服务不投降。

---

## 2. 核心架构：[LSM-Tree](#9-关键术语表) 存储策略

### 2.1 什么是 [LSM-Tree](#8-关键术语表)？
[LSM-Tree](#8-关键术语表) (Log-Structured Merge-Tree) 不是一种单一的数据结构，而是一种**存储策略**。它主张“所有写操作都先写内存，攒够了再批量顺序写磁盘”。

**深度解析：顺序写 vs 随机写**
*   **随机写 (Random Write)**：类似于在图书馆找书，如果你要找 10 本分布在不同楼层的书，你需要不停地跑动、坐电梯、翻找，大部分时间浪费在“寻找”上。传统 B+ Tree 索引的就地更新就是随机写。
*   **顺序写 (Sequential Write)**：类似于在纸上一行一行写字。你不需要翻页或跳跃，笔尖始终在移动。
*   **性能差异**：在机械硬盘（HDD）上，顺序写比随机写快近千倍；在固态硬盘（SSD）上，顺序写也能显著减少磨损并提升吞吐量。

[LSM-Tree](#8-关键术语表) 的核心技巧就是：**通过内存缓冲区和后台[合并 (Compaction)](#8-关键术语表)，将应用程序的“随机写”操作，在磁盘层面转化为“顺序写”操作。**

### 2.2 为什么选择 [LSM-Tree](#8-关键术语表)？
1. **极致的写入性能**：所有的写入都是追加操作（Append-only），利用了磁盘最擅长的顺序 I/O。
2. **适应现代硬件**：对 SSD 极其友好，减少了随机小块写入带来的 GC 压力。
3. **分层管理**：通过后台的 [Compaction（合并）](#8-关键术语表) 过程，逐步清理旧数据，保持数据的有序性。

**推荐阅读**：
建议阅读《数据密集型应用系统设计 (DDIA)》第三章 "Storage and Retrieval"，其中详细对比了 B-Tree 和 [LSM-Tree](#8-关键术语表) 的优劣：
- **[写入放大 (Write Amplification)](#8-关键术语表)**：[LSM-Tree](#8-关键术语表) 通常具有更低的写入放大，适合写密集型负载。
- **顺序 I/O**：即使在 SSD 上，顺序写也能减少擦写次数，延长设备寿命。

---

## 3. 内存组件：MemTable 与跳表

### 3.1 MemTable 的作用
MemTable 是数据进入数据库的第一站。它驻留在内存中，负责暂存最近写入的数据，并保持数据的**有序性**，以便支持快速的范围查询。

### 3.2 为什么用跳表 (SkipList) 实现？
1. **实现简单**：相比红黑树或 AVL 树，跳表的实现逻辑更清晰，代码量通常只有平衡树的 1/3。
2. **并发友好**：在多线程环境下，跳表的无锁化或细粒度锁实现比平衡树更高效。LevelDB 和 RocksDB 选择跳表作为 MemTable 的核心原因之一，就是因为它只需要简单的 CAS 操作就能支持无锁并发读写，而平衡树的旋转操作在并发下极难维护。
3. **性能稳定**：平均查询时间复杂度为 $O(\log n)$，与平衡树相当。

### 3.3 跳表的基本原理
跳表通过在普通链表之上建立“多层索引”来实现快速跳转。
- **层级 (Level)**：每个节点被随机分配一个高度。
- **查找**：从最高层开始，如果当前层的下一个节点比目标大，则下沉到低一层继续查找。

### 3.4 跳表核心操作图解

为了更好地理解跳表，我们可以将其想象成**多层链表**或**地铁快慢车系统**。

#### 3.4.1 结构总览
假设跳表中存储了 `3, 6, 7, 9, 12`。
- **Level 0 (最底层)**：包含所有数据的普通链表（站站停）。
- **Level N (高层)**：快速通道，节点稀疏，跨度大。

```text
Level 2:  HEAD ---------------------> 7 --------------------------> NULL
Level 1:  HEAD ---------> 3 --------> 7 --------> 9 --------------> NULL
Level 0:  HEAD ---------> 3 -> 6 ---> 7 -> 9 ---> 12 -> 19 -------> NULL
```

#### 3.4.2 插入操作详解 (以插入 Key=8 为例)

插入操作的核心思想是：**先找位置，再织网**。

**步骤一：寻找前驱 (Find Predecessors)**
我们需要找到每一层中，目标 Key (8) 应该跟在谁后面。这些节点被称为“前驱节点”，我们用 `update[]` 数组记录它们。

1.  **Level 2**: `HEAD -> 7` (< 8)，`7 -> NULL` (停)。`update[2] = 7`
2.  **Level 1**: `7 -> 9` (> 8)，停。`update[1] = 7`
3.  **Level 0**: `7 -> 9` (> 8)，停。`update[0] = 7`

此时 `update[]` 指向每一层中 8 的前一个节点。

**步骤二：穿针引线 (Link Pointers)**
假设随机生成的新节点 8 的高度为 1 (包含 Level 0, 1)。我们需要将其插入到 `update` 节点之后。

核心逻辑：
1.  **新节点的下家** 接管 **前驱的下家**。
2.  **前驱的下家** 变更为 **新节点**。

```text
Level 1: ... 7 -> 8 (New) -> 9 ...  (8 接管了 9，7 指向了 8)
Level 0: ... 7 -> 8 (New) -> 9 ...
```

这样，新节点就安全地“挂”到了现有的网状结构中。

#### 3.4.3 复杂度分析

- **时间复杂度**：
    - **查找、插入、删除**：平均情况 $O(\log n)$，最坏情况 $O(n)$（极小概率退化为普通链表）。
    - 这里的 $\log n$ 来源于跳表的层数结构，类似于二分查找的排除过程。
- **空间复杂度**：
    - $O(n)$。虽然有额外的指针开销，但期望的指针总数是 $2n$（每层节点数减半级数求和）。

#### 3.4.4 查找操作详解 (Search)

查找操作的目标是：给定 `key`，在跳表中定位对应节点并返回其 `value`。跳表的查找可以理解为“高层快速定位 + 底层精确确认”。

**查找的关键直觉：**
- **Level 0** 一定包含所有节点，是“真实数据链”。
- 更高层（Level 1/2/...）是“稀疏索引层”，并不包含所有 key，只负责加速跳跃。

**查找步骤（从高到低）：**
1. 从 `head` 出发，站在最高层 `current_level - 1`。
2. 在当前层反复向右移动：只要 `forward[i]` 存在且 `forward[i]->key < key` 就前进。
3. 走不动时下沉一层，继续第 2 步。
4. 最终到达 Level 0 后，`current` 停在目标 key 的“前驱节点”上；候选节点是 `current->forward[0]`。
5. 若候选节点存在且 `candidate->key == key`，命中；否则未命中。

**为什么最终必须回到 Level 0 才能确认命中？**
- 因为索引层是抽样出来的节点集合，高层不保证存在目标 key；高层只能缩小范围，最终的等值判断以 Level 0 为准。

#### 3.4.5 Search 的复杂度与工程注意事项

- **时间复杂度**：
    - 平均 $O(\log n)$；最坏 $O(n)$。
    - 经验理解：每上升一层，节点数量期望减半，因此“向右移动的总次数”近似对数级。
- **空间复杂度**：$O(1)$（只使用少量指针变量，不需要 `update[]`）。
- **返回值语义**：
    - 推荐返回 `std::optional<V>` 来表达“可能未命中”，未命中时返回 `std::nullopt`，避免用特殊值造成歧义。
- **与 Insert 的关系**：
    - Insert 的第一阶段与 Search 完全同构：都是“从高层向右，再下沉”的定位过程。
    - Insert 额外需要 `update[]` 记录每层前驱用于穿针引线；Search 不修改结构，因此不需要 `update[]`。
- **Key 类型约束**：
    - 代码通常依赖 `K` 支持 `operator<` 与 `operator==`。
    - 若未来希望支持自定义排序规则，可在 `SkipList` 内引入比较器（Comparator）。
- **边界情况检查清单**：
    - 空表：`head->forward[0] == nullptr` 直接未命中。
    - 最小 key：高层几乎不右移，最终检查 `head->forward[0]`。
    - 最大 key：高层会频繁右移，最终落到最接近 key 的前驱节点。
    - 未命中：候选节点为空或 key 不相等。

#### 3.4.6 删除操作详解 (Remove)

删除操作的目标是：给定 `key`，将对应节点从跳表的各层链表中“断链”，使其在逻辑上不可达（后续 `search(key)` 未命中）。

**删除的关键直觉：**
- 删除与插入的第一阶段完全同构：都需要“从高层向右移动，再逐层下沉”，并在每一层记录目标 key 的前驱节点到 `update[]`。
- 删除本质是“拆网”：用 `update[]` 在每一层把指向目标节点的指针改为跨过它。

**删除步骤（与本项目实现对齐）：**
1. **构造 `update[]`（Find Predecessors）**：
   - 从 `head` 出发，站在最高层 `current_level - 1`。
   - 在每一层尽量向右走，直到 `forward[i]->key >= key` 或到达 NULL；此时 `current` 是该层前驱，记录 `update[i] = current`。
2. **定位候选目标节点 `target`**：
   - 候选节点位于 Level 0：`target = update[0]->forward[0]`。
   - 若 `target == nullptr` 或 `target->key != key`：说明 key 不存在，删除失败。
3. **逐层断链（Unlink Pointers）**：
   - 从 `i=0` 到 `i=current_level-1`：
     - 只有当 `update[i]->forward[i] == target` 时，才执行 `update[i]->forward[i] = target->forward[i]`。
   - 为什么需要这个判断：因为 `target` 的高度可能小于 `current_level`，更高层本来就不包含该节点；对这些层不应修改指针。
4. **收缩 `current_level`**：
   - 删除后如果最高层只剩 `head`（即 `head->forward[current_level - 1] == nullptr`），就应当将 `current_level` 逐层下调，直到该层非空或降到 1。
   - 这不会影响正确性，但能避免“空层”带来的额外遍历开销。

**3.4.6.1 update[] 与断链示意图**

为了把“断链”直观化，可以把删除理解为：在每一层把 `update[i]` 指向 `target` 的边，改成指向 `target` 的后继。

```text
假设要删除 key=8，且 Level 0/1 都包含该节点：

Before（断链前）
Level 1: ... 7 (update[1]) -> 8 (target) -> 9 -> ...
Level 0: ... 7 (update[0]) -> 8 (target) -> 9 -> ...

After（断链后）
Level 1: ... 7 (update[1]) -----------> 9 -> ...
Level 0: ... 7 (update[0]) -----------> 9 -> ...
```

```text
注意：target 的高度可能不足以出现在更高层。
例如 target 只出现在 Level 0 时：
Level 1: ... 7 (update[1]) -> 9 -> ...        （这一层没有 8）
Level 0: ... 7 (update[0]) -> 8 (target) -> 9 -> ...
因此断链时必须先判断：update[i]->forward[i] == target
```

**物理删除 vs Tombstone（联系 MemTable/LSM 的真实语义）**
- **物理删除（本任务做法）**：节点从链表断开后不可达；若同时释放内存，则该节点占用的内存也被回收。
- **Tombstone（LSM 常见做法）**：并不立即物理移除，而是写入“删除标记”，后续通过 Compaction 清理；这样才能正确处理“删除覆盖旧值”的语义，并避免跨层文件间的歧义。

**本项目的内存所有权模型（工程注意事项）**
- forward 中使用的是裸指针，但节点由 `nodes_storage`（`std::unique_ptr` 容器）统一持有。
- 因此删除至少需要完成“断链”（保证逻辑不可达）；若希望回收内存，需要同时从 `nodes_storage` 中擦除对应 `unique_ptr`。

**阶段策略（本项目当前选择）**
- 当前阶段（仅 MemTable/跳表）：先实现并验收物理删除（断链 + 从 `nodes_storage` 擦除以回收内存）。
- 后续阶段（引入 SSTable 并打通 Get/Compaction）：删除语义迁移为 Tombstone，并由 Compaction 负责清理旧版本与删除标记。

#### 3.4.7 Remove 的时空复杂度与工程注意事项

- **时间复杂度**：
    - 平均 $O(\log n)$：构造 `update[]` 需要一次“从高到低”的查找；断链最多改动 `current_level` 条指针；收缩层级最多下降到 1。
    - 最坏 $O(n)$：当跳表退化（极端概率或数据/随机性导致接近链表）时，定位前驱会退化为线性扫描。
- **额外空间复杂度**：
    - $O(\text{max\_level})$：`update[]` 需要为每一层保存一个前驱指针。
    - 其余为 $O(1)$：少量临时指针变量。
- **工程注意事项**：
    - 断链时必须检查 `update[i]->forward[i] == target`，避免访问 `target->forward[i]` 的越界风险（target 高度不足时更高层不存在该指针）。
    - 删除后收缩 `current_level` 能减少后续 `search/insert/remove` 在空层的无效遍历。
    - 本项目用 `nodes_storage`（`std::vector<std::unique_ptr<Node<...>>>`）持有节点：若你选择“真物理删除并回收内存”，需要从该容器中擦除；该擦除是线性查找 + `erase`，单次可能是 $O(n)$ 的移动成本（作为教学实现可以接受，后续可再工程化优化）。

### 3.5 跳表单元测试（insert/search/remove）

在本项目中，跳表的单元测试位于：
- `tests/skiplist_test.cpp`

当前测试范围聚焦于 `insert/search/remove` 的基础正确性与“多层路径是否能走通”。为了让测试稳定可复现（不被随机层数干扰），测试中刻意使用了两种极端概率：
- `prob = 0.0f`：`random_level()` 恒为 1，跳表退化为单层有序链表，便于验证最基础的插入与查询
- `prob = 1.0f`：节点层数恒增长到 `max_level`，用于覆盖扩层与多层 `forward` 指针维护路径

#### 3.5.1 当前已实现用例覆盖点（7 个）

- 空表查找应未命中
- 单条插入后应命中；未插入 key 仍未命中
- 重复插入同 key 的语义：更新 value（以当前实现为准）
- 顺序批量插入后逐个查询应全部命中且值正确
- 乱序插入后逐个查询应全部命中且值正确
- 强制全升层（`prob=1.0f`）下，插入与查询应正确
- `std::string` 作为 key 的模板实例化与比较路径可用

#### 3.5.2 remove 建议覆盖点（待实现）

为了补齐删除逻辑的正确性，建议至少覆盖以下路径（优先固定 `prob=0.0f` 让结构退化为单层，便于稳定复现）：

- 删除不存在的 key：`remove` 返回 false，且表结构不应被破坏（已存在 key 仍可查）。
- 插入→删除→查找：被删 key 查不到；未删 key 仍可查。
- 删除后再插入同 key：应能重新插入并查到新 value。
- 随机删除一半：插入 `[0,n)`，打乱后删除前半；验证已删查不到、未删查得到。
- （可选增强）使用 `prob=1.0f` 覆盖多层断链路径，验证多层 forward 的一致性。

#### 3.5.3 验收结果记录

- 运行方式：构建后执行 `ctest --output-on-failure`
- 最近一次结果：7/7 tests passed（insert/search 相关测试全部通过）
- remove 增补后结果：（待你实现 remove 与新增测试后填写）


---

## 4. 分布式共识：[Raft](#8-关键术语表) 协议
[Raft](#8-关键术语表) 是目前工业界最流行的分布式一致性算法。它将复杂的问题分解为三个子问题：
1. **Leader 选举**：集群中始终有一个 Leader 负责处理所有客户端请求。
2. **日志复制**：Leader 将操作记录同步给 Follower，只有大多数节点确认后，数据才算“提交”。
3. **安全性**：通过[任期 (Term)](#8-关键术语表)和日志索引 (Index) 保证历史数据不被覆盖。

---

## 5. 现代 C++ 内存管理：智能指针与 RAII

### 5.1 什么是 RAII？
**RAII** (Resource Acquisition Is Initialization)，即“资源获取即初始化”。它是 C++ 语言中最核心的编程思想之一。

**核心逻辑：**
1. **获取资源即初始化**：在对象的**构造函数**中获取资源（如申请内存、打开文件、加锁）。
2. **释放资源即析构**：在对象的**析构函数**中释放资源。
3. **绑定生命周期**：将资源的生命周期与局部对象的生命周期绑定。只要对象被销毁（如离开作用域），资源就会自动释放。

**为什么它很伟大？**
- **防泄漏**：即使函数中间抛出异常或提前 `return`，析构函数也一定会被调用。
- **自动化**：程序员不再需要手动写 `delete`、`fclose()` 或 `unlock()`，减少了心智负担。

**本项目中的应用：**
- **智能指针**：`std::unique_ptr` 封装了裸指针的 `new/delete`。
- **文件流**：`std::ofstream` 离开作用域自动关闭文件。
- **并发锁**：`std::lock_guard` 离开作用域自动释放互斥锁（后续 Raft 实现中会大量使用）。

---

### 5.2 三大智能指针详解

#### 1. `std::unique_ptr`（独占所有权）
- **核心思想**：同一时间只能有一个指针拥有该对象的所有权。
- **特点**：
    - 不可拷贝，只能移动（`std::move`）。
    - 几乎没有性能开销（与裸指针性能一致）。
- **什么是“移动” (Move)？**
    - **通俗理解**：拷贝是“复印”，移动是“过户”。
    - **底层原理**：移动不会产生新的数据副本。它只是把原指针内部指向内存的地址“偷”过来，给新指针，然后把原指针置为空（nullptr）。
    - **为什么要移动？**：性能极高。比如一个管理 1GB 内存的对象，拷贝需要复制 1GB 数据，而移动只需要复制一个 8 字节的地址指针。
    - **语法**：使用 `std::move(ptr)` 将左值强制转换为右值引用，从而触发移动构造函数。
- **适用场景**：
    - **默认选择**：当你需要一个局部的、生命周期明确的对象时。
    - **容器管理**：如本项目的 `nodes_storage`，由 `SkipList` 独占所有节点的所有权。

#### 2. `std::shared_ptr`（共享所有权）
- **核心思想**：通过**引用计数**实现多个指针共享同一个对象。
- **缺点：循环引用（Circular Reference）**：
    - **为什么不得不互相引用？**
        - **父子关系**：在 GUI 框架中，父窗口拥有子按钮（`shared_ptr`），但子按钮有时需要回调父窗口的方法（如果也用 `shared_ptr`，就循环了）。
        - **双向链表**：前驱节点指向后继，后继也指向前驱。
        - **观察者模式**：被观察者（Subject）通知观察者，观察者（Observer）有时也需要取消订阅（反向引用）。
    - **后果**：它们的引用计数永远至少为 1，导致即便外部已经没有任何指针指向它们，它们也永远不会被销毁。这就是内存泄漏！

#### 3. `std::weak_ptr`（弱引用）
- **核心思想**：它是 `shared_ptr` 的“观察者”。它指向对象，但**不增加引用计数**。
- **为什么使用前必须调用 `lock()`？**
    - **安全性保证**：`weak_ptr` 不拥有对象，它指向的对象可能随时被其他线程释放。
    - **原子操作**：`lock()` 是一个原子操作。它会检查对象是否还活着：
        - 如果还活着，它会把引用计数 **+1**，并返回一个临时的 `shared_ptr`。只要这个 `shared_ptr` 还在，对象就绝对不会在你处理逻辑时被删掉。
        - 如果对象已经没了，它返回一个空的 `shared_ptr`。
    - **如果不 lock 而是直接使用会怎样？**：你可能在第一行代码判断它还活着，但在第二行真正访问成员时，对象刚好被删了，程序会直接崩溃（段错误）。
- **如何配合使用？**
    - **打破循环**：在双向关系中，一方持强引用（`shared_ptr`），另一方持弱引用（`weak_ptr`）。
    - **代码示例**：
        ```cpp
        std::weak_ptr<int> wp = sp; // sp 是 shared_ptr
        // wp.use_count() 不会增加
        if (auto locked_sp = wp.lock()) {
            // 此时 locked_sp 是一个新的 shared_ptr，计数 +1
            // 即使外部的 sp 被销毁，locked_sp 也能保证对象在这里是安全的
            std::cout << *locked_sp << std::endl;
        } // 函数结束，locked_sp 销毁，计数 -1
        ```

### 5.3 决策指南：该选哪种？

| 场景 | 推荐方案 | 理由 |
| :--- | :--- | :--- |
| **大部分情况** | `std::unique_ptr` | 性能最优，职责最清晰。 |
| **需要多个拥有者** | `std::shared_ptr` | 自动处理复杂的生命周期共享。 |
| **打破循环引用** | `std::weak_ptr` | 防止 A 引用 B，B 又引用 A 导致的永久不释放。 |
| **底层性能敏感/算法实现** | 裸指针 (`T*`) | 仅用于**观察**（不拥有所有权），如跳表节点间的 `forward` 链接。 |

### 5.4 现代 C++：std::optional 与 std::nullopt

在 C++ 中，“函数是否有返回结果”经常是业务语义的一部分。例如跳表的 `search(key)`：可能命中，也可能未命中。`std::optional` 用类型系统把这种“有/无”的语义表达出来。

#### 5.4.1 `std::optional<T>`：可能有值的返回类型

- **定义**：`std::optional<T>` 表示“一个可能存在、也可能不存在的 `T` 值”。它要么装着一个 `T`，要么为空。
- **典型场景**：
    - 查找：命中返回值，未命中返回空。
    - 解析：解析成功返回结果，失败返回空。
    - 缓存：命中返回对象，未命中返回空。
- **为什么不直接返回 `T`？**
    - 如果返回 `T`，未命中时通常只能返回一个“特殊值”（例如 `-1`、空字符串），但特殊值可能与合法值冲突，产生歧义。
    - `optional` 让调用者必须显式处理“无值”分支，可读性更强。

#### 5.4.2 `std::nullopt`：表示“空的 optional”

- **含义**：`std::nullopt` 是一个标记量，用来表示“这里没有值”。常用于构造/返回一个空的 `std::optional<T>`。
- **示例**：`return std::nullopt;` 表示“未找到 / 不存在 / 没有结果”。

#### 5.4.3 常用 API（写测试时会频繁用到）

- 判断是否有值：
    - `if (opt) { ... }`
    - `if (opt.has_value()) { ... }`
- 取值（必须确保有值）：
    - `*opt`
    - `opt.value()`（无值会抛异常）
- 带默认值取值：
    - `opt.value_or(default_value)`（无值时返回默认值，不抛异常）

#### 5.4.4 在本项目中的应用：跳表 Search

在本项目中，`SkipList::search` 返回 `std::optional<V>`：
- 命中：返回包含 `value` 的 `optional`。
- 未命中：返回 `std::nullopt`。

这样调用者可以清晰地区分“找到了一个值”和“没找到”，而无需约定一个可能冲突的特殊返回值。

### 5.5 C++17：结构化绑定（Structured Bindings）

结构化绑定（Structured Bindings）是 C++17 引入的一种语法糖，用于把“可拆分”的对象（如 `std::pair` / `std::tuple` / `struct` / 数组）一次性拆成多个变量，提升可读性。

#### 5.5.1 最常见的形式：拆 `std::pair`

```cpp
std::pair<int, std::string> p{1, "one"};
auto [k, v] = p;  // k 是 int，v 是 std::string（注意：这里是拷贝/移动）
```

对应到我们的测试代码：

```cpp
for (const auto& [k, val] : expected) {
    // ...
}
```

这里 `expected` 是 `std::unordered_map<int, std::string>`，它遍历时得到的元素类型本质上是 `std::pair<const int, std::string>`，结构化绑定把它拆成：
- `k`：key（类型是 `const int`，因此不能修改 key）
- `val`：value（类型是 `std::string`，但由于外层是 `const auto&`，因此此处 `val` 也是只读引用）

#### 5.5.2 `auto` / `auto&` / `const auto&` 的区别（非常关键）

- `auto [a, b] = obj;`
  - 生成两个新变量，通常会发生拷贝/移动。
  - 修改 `a/b` 不会影响 `obj`。
- `auto& [a, b] = obj;`
  - 绑定为引用，`a/b` 直接引用 `obj` 里的成员。
  - 修改 `b` 会影响原对象（对 `map/unordered_map` 而言，`a` 是 key，通常是 `const` 不能改）。
- `const auto& [a, b] = obj;`
  - 只读引用绑定，常用于遍历容器时避免拷贝，同时保证不修改元素。

在范围 for 中我们写 `for (const auto& [k, val] : expected)` 的效果是：
- 不拷贝 map 里的元素（更高效）
- 不允许在循环中意外改动 key/value（更安全）

#### 5.5.3 还能拆哪些类型？

- 拆 `std::tuple`：
  - `auto [x, y, z] = std::tuple{1, 2.0, "hi"};`
- 拆简单 `struct`（需要 public 成员）：
  - `struct S { int x; int y; }; S s{1,2}; auto [x, y] = s;`
- 拆数组：
  - `int a[2] = {1,2}; auto [x, y] = a;`

#### 5.5.4 记一个避免踩坑的规则

如果你想“在遍历时修改容器元素的 value”，应写：

```cpp
for (auto& [k, v] : mp) {
    v += 1;
}
```

而不是 `auto [k, v]`，因为后者会把元素拷贝出来，你修改的是副本。

---

## 6. 构建系统与 CMake

### 6.1 CMake 是什么？
CMake 是一套跨平台的构建配置系统，它通过读取 `CMakeLists.txt` 来生成不同平台的构建文件（如 Ninja、Unix Makefiles、Visual Studio 工程）。核心思想是用“目标”来表达库和可执行文件，以及它们之间的依赖、编译选项和链接关系。

### 6.2 本项目的构建现状
本项目使用 CMake 作为构建系统，并通过 CTest 运行测试用例：
- 根目录存在 `CMakeLists.txt`，会构建跳表测试可执行文件（如 `skiplist_test`）
- 测试框架使用 GoogleTest（GTest），并通过 CMake 的 `gtest_discover_tests` 自动注册到 CTest
### 6.2 本项目的构建现状
仓库根目录提供了 `build.ps1` (PowerShell) 脚本，旨在简化 Windows 环境下的构建流程。

**脚本功能：**
1. **自动检测 CMake**：会在常见路径（如 Visual Studio 组件目录、默认安装目录）下查找 `cmake.exe`。
2. **智能选择生成器**：
   - 优先检测 `Ninja` (最快)。
   - 其次检测 `MinGW Makefiles` (如果安装了 MinGW 且有 `mingw32-make` 或 `make`)。
   - 最后回退到默认生成器 (通常是 Visual Studio MSBuild)。
3. **依赖管理**：自动配置 `googletest`，并设置了 `-DCMAKE_TLS_VERIFY=OFF` 以解决部分网络环境下的 SSL 证书问题。
4. **一键测试**：构建完成后自动运行 `ctest`，输出测试结果。

**使用方法：**
```powershell
# 默认构建
.\build.ps1

# 清理并重新构建
.\build.ps1 --clean
```

### 6.3 是否有比 CMake 更高级的？
从行业现状看，CMake 仍是 C++ 领域最主流的构建系统之一，尤其在跨平台库、系统级软件和开源项目中依然占主导。与此同时，Bazel、Meson、XMake 等更现代的方案在部分团队中增长，但并没有形成对 CMake 的全面替代，它们只是不同的工程取舍。

### 6.4 该用哪种构建系统？
建议优先选择 CMake 作为本项目的构建系统。理由是生态成熟、工具链支持广、与主流 IDE 和 CI 集成简单，且学习资料丰富。等项目规模显著扩大、需要更强的缓存与大规模构建能力时，再评估 Bazel 或其他方案会更稳妥。

---
 
## 7. 编码规范与文档化
 
 ### 7.1 Doxygen 注释规范
 本项目采用 Doxygen 风格的文档注释，以便于 IDE 智能提示和自动生成 API 文档。
 - **格式**：使用 `/** ... */` 开头。
 - **常用标签**：
   - `@brief`：简要描述功能。
   - `@tparam`：描述模板参数。
   - `@param`：描述函数参数。
   - `@return`：描述返回值。
 
 ---
 
 ## 8. 学习路径建议
1. **第一阶段：单机存储核心**
   - 实现一个线程安全的跳表（SkipList）。
   - 学习如何使用 `mmap` 或 `fwrite` 实现 [WAL](#8-关键术语表)。
   - 实现简单的 [SSTable](#8-关键术语表) 读取与查询。
2. **第二阶段：Raft 算法实现**
   - 编写状态机逻辑。
   - 模拟节点间的 RPC 通信（可以先在单机模拟多个线程代表不同节点）。
3. **第三阶段：网络与集成**
   - 学习 C++ 协程库（如 `asio` 或自研简单的协程调度器）。
   - 将 Raft 与 LSM-Tree 结合，实现真正的分布式 KV 存储。

---
 
 ## 9. 关键术语表
- **LSM-Tree (Log-Structured Merge-Tree)**：一种将随机写转换为顺序写的存储策略，通过内存 MemTable 和磁盘 SSTable 的多层合并实现。
- **Raft**：一种易于理解的分布式共识算法，负责在集群中达成一致性。
- **Term (任期)**：Raft 中的逻辑时间单位。
- **Commit Index**：已知已提交的最高日志索引。
- **SSTable (Sorted String Table)**：持久化在磁盘上的有序键值对文件。
- **Write-Ahead Log (WAL)**：用于崩溃恢复的顺序日志文件。
- **Compaction**：后台线程定期合并多个小文件，删除冗余数据。
- **Write Amplification (写入放大)**：实际写入磁盘的数据量与用户请求写入的数据量之比。在 LSM-Tree 中，由于数据需要不断在各层之间进行合并重写，会产生较大的写入放大。
- **Read Amplification (读取放大)**：为了找到一个 Key，需要查询多个文件（MemTable + 各层 SSTable）而导致的多次 I/O。
- **Space Amplification (空间放大)**：由于保留了旧版本数据或被标记删除的数据，磁盘实际占用空间大于有效数据量。
 
 ---
 
 ## 10. 项目计划（周级细化）
 
 ### 10.1 阶段 A：单机存储引擎（第 1–6 周）

**第 1 周：LSM-Tree 与 MemTable 基础**

本周目标：搭建项目骨架，理解 LSM-Tree 核心思想，并完成跳表（SkipList）的基础结构设计与空跑测试。

*   **任务一：理论预热与环境准备（已完成）**
    *   **复习**：回顾本文第 2 章与第 3 章，深入理解 LSM-Tree 的顺序写优势及跳表的选型理由。
    *   **实战**：检查 C++ 编译器（GCC/Clang）与 CMake 环境。
 
 *   **任务二：项目工程化搭建（已完成）**
    *   **实战**：创建项目目录结构：
         *   `src/`：源代码
         *   `include/`：头文件
         *   `tests/`：测试代码
         *   `docs/`：文档
    *   **实战**：编写根目录 `CMakeLists.txt`，配置基础编译选项（建议开启 `-std=c++17` 或更高，以及 `-Wall -g`）。
 
 *   **任务三：跳表核心数据结构设计（已完成）**
    *   **代码**：定义 `SkipList` 模板类（支持泛型 Key 和 Value）。
    *   **代码**：设计内部 `Node` 结构体：
         *   成员：`Key`, `Value`
         *   成员：`forward` 指针数组（用于指向不同层级的下一个节点）
    *   **代码**：理解并实现“最大层数”与“概率因子”常量的定义。

*   **任务四：随机层数生成与辅助函数（已完成）**
    *   **理论**：理解跳表节点高度的随机生成机制（几何分布）。
    *   **代码**：实现 `random_level()` 函数，确保生成的层数符合概率分布。
    *   **代码**：实现构造函数与析构函数，注意内存管理（使用智能指针管理节点）。

*   **任务五：核心接口声明 (API Design) (已完成)**
    *   **代码**：在头文件中完成核心功能的接口声明（暂不实现具体逻辑）：
        *   `insert(key, value)`
        *   `search(key)`
        *   `remove(key)` (注：LSM 中通常标记删除，但基础跳表可先实现物理删除)
    *   **代码**：编写一个简单的 `main.cpp`，实例化 `SkipList` 对象并调用上述空接口，确保编译通过。

*   **任务六：单元测试框架接入 (已完成)**
    *   **实战**：引入 Google Test (GTest) 库（推荐通过 CMake FetchContent 自动下载，或手动配置）。
    *   **实战**：编写第一个“冒烟测试”：创建一个跳表对象，断言其初始化状态（如当前层级为 0，头节点存在等）。
    *   **验收**：运行 `ctest` 或执行测试二进制文件，看到绿色的 `PASSED`。

**第 2 周：跳表核心实现与稳定性测试**

本周目标：完成跳表（SkipList）的完整增删改查（CRUD）功能，通过大规模随机测试验证正确性与内存安全性。

*   **任务一：实现核心插入逻辑 (Insert)（已完成）**
    *   **理论**：理解跳表的“寻找前驱节点”机制。在每一层中，找到小于目标 Key 的最后一个节点，记录在 `update[]` 数组中。
    *   **代码**：实现 `insert(key, value)`。
        *   步骤 1：定位插入位置，生成 `update` 路径。
        *   步骤 2：检查 Key 是否已存在。若存在，更新 Value 并返回。
        *   步骤 3：调用 `random_level()` 生成新节点高度。若新高度超过当前 `max_level`，需扩展 `update` 数组指向头节点。
        *   步骤 4：创建新节点，并逐层调整指针（`new_node->forward = prev->forward; prev->forward = new_node;`）。

*   **任务二：实现精确查找 (Search)（已完成）**
    *   **代码**：实现 `search(key)`。
    *   **逻辑**：从最高层出发，向右移动直到下一个节点大于 Key，然后下沉一层。最终在第 0 层判断下一个节点是否等于目标 Key。

*   **任务三：实现删除逻辑 (Remove)**
    *   **代码**：实现 `remove(key)`。
    *   **逻辑**：
        *   利用 `update` 数组找到目标 Key 的所有前驱节点。
        *   逐层断开链接：`update[i]->forward[i] = target->forward[i]`。
        *   **注意**：删除后需检查是否需要降低跳表的 `current_max_level`（如果最高层只剩头节点）。
    *   **策略**：本周先以物理删除完成数据结构验收；当第 4–6 周引入 SSTable/Compaction 后，删除语义切换为 Tombstone 与 LSM 对齐。

*   **任务四：大规模随机性测试 (Stability Test)（部分完成）**
    *   **实战**：编写 `tests/skiplist_test.cpp`。
    *   **测试用例 1**：顺序插入 0-10000，验证查询成功。
    *   **测试用例 2**：随机插入 10000 个乱序整数，验证查询成功。
    *   **测试用例 3**：随机删除 5000 个元素，验证剩余元素可查，已删元素查不到。
    *   **工具**：开启 AddressSanitizer (`-fsanitize=address`) 运行测试，确保无内存泄漏。
    *   **当前进度**：insert/search 的用例已补齐并通过；remove 相关用例待补。

*   **任务五：简单性能基准测试 (Benchmark)**
    *   **实战**：编写 `examples/benchmark_skiplist.cpp`。
    *   **比较**：对比 `SkipList` 与 `std::map` (红黑树) 在 10 万级数据下的插入与读取耗时。
    *   **预期**：跳表性能应与红黑树在同一数量级（$O(\log n)$）。

**第 3 周：WAL 预写日志**
- 学习内容：顺序写、崩溃恢复基本概念
- 开发任务：实现 WAL 写入与重放逻辑，确保写入先落盘
- 验收标准：模拟进程崩溃后能重建 MemTable

**第 4 周：SSTable 文件格式**
- 学习内容：有序文件结构、索引与数据块布局
- 开发任务：实现 SSTable 写入与加载接口
- 验收标准：MemTable flush 到 SSTable 后可正确读取

**第 5 周：查询路径打通**
- 学习内容：读路径分层（MemTable + SSTable）
- 开发任务：实现 Get 查询链路，先查 MemTable，再查 SSTable
- 验收标准：同时覆盖内存与磁盘数据的查询正确性

**第 6 周：Compaction 合并**
- 学习内容：分层合并策略、重复键处理
- 开发任务：实现基础 Compaction 流程
- 验收标准：磁盘文件数量可控，旧数据正确被淘汰

### 10.2 阶段 B：Raft 共识协议（第 7–12 周）

**第 7 周：Raft 状态机框架**
- 学习内容：Leader/Follower/Candidate 状态转移
- 开发任务：实现 Raft 状态机骨架与超时机制
- 验收标准：单机多线程模拟选举流程

**第 8 周：日志复制**
- 学习内容：AppendEntries 原理与心跳机制
- 开发任务：实现日志同步与心跳
- 验收标准：Leader 写入后 follower 日志保持一致

**第 9 周：日志冲突处理**
- 学习内容：日志对齐与冲突回滚
- 开发任务：实现冲突条目回滚逻辑
- 验收标准：节点恢复后日志可自动对齐

**第 10 周：提交与一致性保证**
- 学习内容：Commit Index 推进与安全性
- 开发任务：实现提交逻辑
- 验收标准：多数派确认后才对外可见

**第 11 周：快照机制**
- 学习内容：Snapshot 保存与恢复
- 开发任务：实现快照生成与加载接口
- 验收标准：节点重启后可通过快照快速恢复

**第 12 周：Raft 测试与故障注入**
- 学习内容：分布式故障模拟方法
- 开发任务：实现故障注入脚本与测试场景
- 验收标准：Leader 崩溃后系统仍可完成选举

### 10.3 阶段 C：网络层与集成（第 13–16 周）

**第 13 周：RPC 通信框架**
- 学习内容：异步 IO、序列化协议
- 开发任务：实现基础 RPC 调用
- 验收标准：节点之间可完成心跳通信

**第 14 周：Raft 与存储层集成**
- 学习内容：状态机与存储引擎的绑定
- 开发任务：实现 Put/Get 请求经 Raft 提交后落盘
- 验收标准：多节点数据一致

**第 15 周：读写性能优化**
- 学习内容：批量写、读缓存策略
- 开发任务：引入批量写入与基础读缓存
- 验收标准：吞吐提升，延迟降低

**第 16 周：集群稳定性测试**
- 学习内容：系统性故障测试设计
- 开发任务：模拟断网、节点崩溃、重启
- 验收标准：系统保持强一致性

### 10.4 阶段 D：工程化与展示（第 17–20 周）

**第 17 周：代码结构与工程化整理**
- 学习内容：模块化设计与目录规范
- 开发任务：整理模块划分与构建脚本
- 验收标准：新开发者可快速理解结构

**第 18 周：性能压测报告**
- 学习内容：基准测试方法
- 开发任务：产出读写性能曲线与测试报告
- 验收标准：性能曲线清晰可复现

**第 19 周：一致性验证**
- 学习内容：正确性测试方法
- 开发任务：构建一致性验证脚本
- 验收标准：多次重复测试无一致性错误

**第 20 周：成果打包与演示**
- 学习内容：项目表达与演示技巧
- 开发任务：编写 Demo 流程与说明材料
- 验收标准：能完整展示项目核心价值

### 10.5 每周投入建议
- 建议每周 12–20 小时投入
- 若每周少于 10 小时，总周期可能延长至 6 个月以上

---

## 11. 测试与验证（GTest/CTest）

### 11.1 单元测试解决什么问题

单元测试（Unit Test）关注“一个很小的单元（函数/类/模块）在给定输入下是否输出符合预期”。它主要解决三类工程问题：
- **回归**：今天修好/写好的功能，明天改代码不会悄悄坏掉
- **定位**：出现 bug 时能快速把问题范围缩到某个模块或某条路径
- **重构保障**：你可以放心整理代码结构，只要测试还是绿的，就说明行为没变

### 11.2 本项目的测试入口

本项目的跳表测试文件：
- `tests/skiplist_test.cpp`

测试是如何跑起来的（理解链路即可，不必死记命令）：
- **GTest**：写断言与测试用例（`TEST(...)`、`EXPECT_EQ(...)` 等）
- **CTest**：统一的测试执行器，负责“发现并运行测试”（配合 CMake）
- **CMake**：把测试目标编译出来，并把 GTest 用例注册给 CTest

### 11.3 ASSERT 与 EXPECT 如何选择

GTest 的断言分两类：
- `EXPECT_*`：失败会记录错误，但继续执行当前测试用例后续语句
- `ASSERT_*`：失败会立刻中断当前测试用例（返回）

经验规则：
- 如果后面的代码依赖“当前断言必须成立”才能安全执行（比如 `optional.value()` 之前必须 `has_value()`），用 `ASSERT_*`
- 如果后面的代码不依赖该条件，用 `EXPECT_*` 让一次运行尽可能收集更多失败信息

### 11.4 常用断言速查

基础断言：
- `EXPECT_TRUE(x)` / `EXPECT_FALSE(x)`
- `EXPECT_EQ(a, b)` / `EXPECT_NE(a, b)`
- `ASSERT_TRUE(x)` / `ASSERT_EQ(a, b)`

`std::optional` 相关：
- `ASSERT_TRUE(opt.has_value())`：确认有值（失败就中断，避免后续 `value()` 不安全）
- `EXPECT_FALSE(opt.has_value())`：确认无值（未命中）
- `EXPECT_EQ(opt.value(), expected)`：对比值（在确认 has_value 之后）

### 11.5 写测试的 AAA 套路

把每个测试都按三段组织，读起来最清晰：
- **Arrange**：准备数据与环境（构造对象、准备输入）
- **Act**：执行动作（调用要测试的函数）
- **Assert**：断言结果（验证输出、状态、不变量）

对应到跳表：
- Arrange：创建 `SkipList`、准备 key/value、固定随机种子或固定概率
- Act：`insert` / `search` / `remove`
- Assert：命中/未命中、值正确、删除后不可再查到

### 11.6 让测试可复现

测试想要“稳定”，要尽量消除不确定性：
- **固定随机种子**：例如 `std::mt19937 rng(12345)`，确保 shuffle 结果固定
- **控制随机层数路径**：用 `prob=0.0f` 或 `prob=1.0f` 覆盖确定路径
- **避免依赖遍历顺序**：`unordered_map` 的遍历顺序不保证稳定，不要把“遍历顺序”作为测试依据
