# DistributedKV 项目学习手册

## 目录
- [1. 项目愿景](#1-项目愿景)
- [2. 核心架构：LSM-Tree 存储策略](#2-核心架构lsm-tree-存储策略)
    - [2.1 什么是 LSM-Tree？](#21-什么是-lsm-tree)
    - [2.2 为什么选择 LSM-Tree？](#22-为什么选择-lsm-tree)
- [3. 内存组件：MemTable 与跳表](#3-内存组件memtable-与跳表)
    - [3.1 MemTable 的作用](#31-memtable-的作用)
    - [3.2 为什么用跳表 (SkipList) 实现？](#32-为什么用跳表-skiplist-实现)
    - [3.3 跳表的基本原理](#33-跳表的基本原理)
- [4. 分布式共识：Raft 协议](#4-分布式共识raft-协议)
- [5. 现代 C++ 异步编程](#5-现代-c-异步编程)
- [6. 构建系统与 CMake](#6-构建系统与-cmake)
    - [6.1 CMake 是什么？](#61-cmake-是什么)
    - [6.2 本项目的构建现状](#62-本项目的构建现状)
    - [6.3 是否有比 CMake 更高级的？](#63-是否有比-cmake-更高级的)
    - [6.4 该用哪种构建系统？](#64-该用哪种构建系统)
- [7. 学习路径建议](#7-学习路径建议)
- [8. 关键术语表](#8-关键术语表)
- [9. 项目计划（周级细化）](#9-项目计划周级细化)
    - [9.1 阶段 A：单机存储引擎（第 1–6 周）](#91-阶段-a单机存储引擎第-16-周)
    - [9.2 阶段 B：Raft 共识协议（第 7–12 周）](#92-阶段-braft-共识协议第-712-周)
    - [9.3 阶段 C：网络层与集成（第 13–16 周）](#93-阶段-c网络层与集成第-1316-周)
    - [9.4 阶段 D：工程化与展示（第 17–20 周）](#94-阶段-d工程化与展示第-1720-周)
    - [9.5 每周投入建议](#95-每周投入建议)

---

## 1. 项目愿景
DistributedKV 旨在通过从零实现 [Raft](#8-关键术语表) 协议与 [LSM-Tree](#8-关键术语表) 存储引擎，深入理解分布式系统的核心挑战：
- **强一致性**：在任何网络分区或宕机情况下，确保数据读写的一致性。
- **高可用性**：集群部分节点故障时，系统仍能正常提供服务。
- **高性能写入**：利用 [LSM-Tree](#8-关键术语表) 的顺序写特性，支持大规模数据的高吞吐写入。

---

## 2. 核心架构：[LSM-Tree](#8-关键术语表) 存储策略

### 2.1 什么是 [LSM-Tree](#8-关键术语表)？
[LSM-Tree](#8-关键术语表) (Log-Structured Merge-Tree) 不是一种单一的数据结构，而是一种**存储策略**。它主张“所有写操作都先写内存，攒够了再批量顺序写磁盘”。

**深度解析：顺序写 vs 随机写**
*   **随机写 (Random Write)**：类似于在图书馆找书，如果你要找 10 本分布在不同楼层的书，你需要不停地跑动、坐电梯、翻找，大部分时间浪费在“寻找”上。传统 B+ Tree 索引的就地更新就是随机写。
*   **顺序写 (Sequential Write)**：类似于在纸上一行一行写字。你不需要翻页或跳跃，笔尖始终在移动。
*   **性能差异**：在机械硬盘（HDD）上，顺序写比随机写快近千倍；在固态硬盘（SSD）上，顺序写也能显著减少磨损并提升吞吐量。

[LSM-Tree](#8-关键术语表) 的核心技巧就是：**通过内存缓冲区和后台[合并 (Compaction)](#8-关键术语表)，将应用程序的“随机写”操作，在磁盘层面转化为“顺序写”操作。**

### 2.2 为什么选择 [LSM-Tree](#8-关键术语表)？
1. **极致的写入性能**：所有的写入都是追加操作（Append-only），利用了磁盘最擅长的顺序 I/O。
2. **适应现代硬件**：对 SSD 极其友好，减少了随机小块写入带来的 GC 压力。
3. **分层管理**：通过后台的 [Compaction（合并）](#8-关键术语表) 过程，逐步清理旧数据，保持数据的有序性。

**推荐阅读**：
建议阅读《数据密集型应用系统设计 (DDIA)》第三章 "Storage and Retrieval"，其中详细对比了 B-Tree 和 [LSM-Tree](#8-关键术语表) 的优劣：
- **[写入放大 (Write Amplification)](#8-关键术语表)**：[LSM-Tree](#8-关键术语表) 通常具有更低的写入放大，适合写密集型负载。
- **顺序 I/O**：即使在 SSD 上，顺序写也能减少擦写次数，延长设备寿命。

---

## 3. 内存组件：MemTable 与跳表

### 3.1 MemTable 的作用
MemTable 是数据进入数据库的第一站。它驻留在内存中，负责暂存最近写入的数据，并保持数据的**有序性**，以便支持快速的范围查询。

### 3.2 为什么用跳表 (SkipList) 实现？
1. **实现简单**：相比红黑树或 AVL 树，跳表的实现逻辑更清晰，代码量通常只有平衡树的 1/3。
2. **并发友好**：在多线程环境下，跳表的无锁化或细粒度锁实现比平衡树更高效。LevelDB 和 RocksDB 选择跳表作为 MemTable 的核心原因之一，就是因为它只需要简单的 CAS 操作就能支持无锁并发读写，而平衡树的旋转操作在并发下极难维护。
3. **性能稳定**：平均查询时间复杂度为 $O(\log n)$，与平衡树相当。

### 3.3 跳表的基本原理
跳表通过在普通链表之上建立“多层索引”来实现快速跳转。
- **层级 (Level)**：每个节点被随机分配一个高度。
- **查找**：从最高层开始，如果当前层的下一个节点比目标大，则下沉到低一层继续查找。

---

## 4. 分布式共识：[Raft](#8-关键术语表) 协议
[Raft](#8-关键术语表) 是目前工业界最流行的分布式一致性算法。它将复杂的问题分解为三个子问题：
1. **Leader 选举**：集群中始终有一个 Leader 负责处理所有客户端请求。
2. **日志复制**：Leader 将操作记录同步给 Follower，只有大多数节点确认后，数据才算“提交”。
3. **安全性**：通过[任期 (Term)](#8-关键术语表)和日志索引 (Index) 保证历史数据不被覆盖。

---

## 5. 现代 C++ 异步编程
- **协程 (Coroutines)**：C++20 的大杀器。它允许我们用同步的逻辑编写复杂的异步网络 IO。
- **内存安全**：严格使用智能指针，杜绝 `new/delete`，模拟 Rust 风格的资源管理。

---

## 6. 构建系统与 CMake

### 6.1 CMake 是什么？
CMake 是一套跨平台的构建配置系统，它通过读取 `CMakeLists.txt` 来生成不同平台的构建文件（如 Ninja、Unix Makefiles、Visual Studio 工程）。核心思想是用“目标”来表达库和可执行文件，以及它们之间的依赖、编译选项和链接关系。

### 6.2 本项目的构建现状
当前仓库中未发现 `CMakeLists.txt` 或其他构建系统配置文件，因此项目尚未确定具体的构建方案。

### 6.3 是否有比 CMake 更高级的？
从行业现状看，CMake 仍是 C++ 领域最主流的构建系统之一，尤其在跨平台库、系统级软件和开源项目中依然占主导。与此同时，Bazel、Meson、XMake 等更现代的方案在部分团队中增长，但并没有形成对 CMake 的全面替代，它们只是不同的工程取舍。

### 6.4 该用哪种构建系统？
建议优先选择 CMake 作为本项目的构建系统。理由是生态成熟、工具链支持广、与主流 IDE 和 CI 集成简单，且学习资料丰富。等项目规模显著扩大、需要更强的缓存与大规模构建能力时，再评估 Bazel 或其他方案会更稳妥。

---

## 7. 学习路径建议
1. **第一阶段：单机存储核心**
   - 实现一个线程安全的跳表（SkipList）。
   - 学习如何使用 `mmap` 或 `fwrite` 实现 [WAL](#8-关键术语表)。
   - 实现简单的 [SSTable](#8-关键术语表) 读取与查询。
2. **第二阶段：Raft 算法实现**
   - 编写状态机逻辑。
   - 模拟节点间的 RPC 通信（可以先在单机模拟多个线程代表不同节点）。
3. **第三阶段：网络与集成**
   - 学习 C++ 协程库（如 `asio` 或自研简单的协程调度器）。
   - 将 Raft 与 LSM-Tree 结合，实现真正的分布式 KV 存储。

---

## 8. 关键术语表
- **LSM-Tree (Log-Structured Merge-Tree)**：一种将随机写转换为顺序写的存储策略，通过内存 MemTable 和磁盘 SSTable 的多层合并实现。
- **Raft**：一种易于理解的分布式共识算法，负责在集群中达成一致性。
- **Term (任期)**：Raft 中的逻辑时间单位。
- **Commit Index**：已知已提交的最高日志索引。
- **SSTable (Sorted String Table)**：持久化在磁盘上的有序键值对文件。
- **Write-Ahead Log (WAL)**：用于崩溃恢复的顺序日志文件。
- **Compaction**：后台线程定期合并多个小文件，删除冗余数据。
- **Write Amplification (写入放大)**：实际写入磁盘的数据量与用户请求写入的数据量之比。在 LSM-Tree 中，由于数据需要不断在各层之间进行合并重写，会产生较大的写入放大。
- **Read Amplification (读取放大)**：为了找到一个 Key，需要查询多个文件（MemTable + 各层 SSTable）而导致的多次 I/O。
- **Space Amplification (空间放大)**：由于保留了旧版本数据或被标记删除的数据，磁盘实际占用空间大于有效数据量。

---

## 9. 项目计划（周级细化）

### 9.1 阶段 A：单机存储引擎（第 1–6 周）

**第 1 周：LSM-Tree 与 MemTable 基础**

本周目标：搭建项目骨架，理解 LSM-Tree 核心思想，并完成跳表（SkipList）的基础结构设计与空跑测试。

*   **任务一：理论预热与环境准备**
    *   **复习**：回顾本文第 2 章与第 3 章，深入理解 LSM-Tree 的顺序写优势及跳表的选型理由。
    *   **实战**：检查 C++ 编译器（GCC/Clang）与 CMake 环境。

*   **任务二：项目工程化搭建**
    *   **实战**：创建项目目录结构：
        *   `src/`：源代码
        *   `include/`：头文件
        *   `tests/`：测试代码
        *   `docs/`：文档
    *   **实战**：编写根目录 `CMakeLists.txt`，配置基础编译选项（建议开启 `-std=c++17` 或更高，以及 `-Wall -g`）。

*   **任务三：跳表核心数据结构设计**
    *   **代码**：定义 `SkipList` 模板类（支持泛型 Key 和 Value）。
    *   **代码**：设计内部 `Node` 结构体：
        *   成员：`Key`, `Value`
        *   成员：`forward` 指针数组（用于指向不同层级的下一个节点）
    *   **代码**：理解并实现“最大层数”与“概率因子”常量的定义。

*   **任务四：随机层数生成与辅助函数**
    *   **理论**：理解跳表节点高度的随机生成机制（几何分布）。
    *   **代码**：实现 `randomLevel()` 函数，确保生成的层数符合概率分布。
    *   **代码**：实现构造函数与析构函数，注意内存管理（避免内存泄漏）。

*   **任务五：核心接口声明 (API Design)**
    *   **代码**：在头文件中完成核心功能的接口声明（暂不实现具体逻辑）：
        *   `insert(key, value)`
        *   `search(key)`
        *   `remove(key)` (注：LSM 中通常标记删除，但基础跳表可先实现物理删除)
    *   **代码**：编写一个简单的 `main.cpp`，实例化 `SkipList` 对象并调用上述空接口，确保编译通过。

*   **任务六：单元测试框架接入**
    *   **实战**：引入 Google Test (GTest) 库（推荐通过 CMake FetchContent 自动下载，或手动配置）。
    *   **实战**：编写第一个“冒烟测试”：创建一个跳表对象，断言其初始化状态（如当前层级为 0，头节点存在等）。
    *   **验收**：运行 `ctest` 或执行测试二进制文件，看到绿色的 `PASSED`。

**第 2 周：跳表实现与稳定性测试**
- 学习内容：随机层级生成、边界条件处理、时间复杂度
- 开发任务：实现跳表插入/查找/删除逻辑
- 验收标准：支持 1 万条键值对插入与随机查找，结果正确

**第 3 周：WAL 预写日志**
- 学习内容：顺序写、崩溃恢复基本概念
- 开发任务：实现 WAL 写入与重放逻辑，确保写入先落盘
- 验收标准：模拟进程崩溃后能重建 MemTable

**第 4 周：SSTable 文件格式**
- 学习内容：有序文件结构、索引与数据块布局
- 开发任务：实现 SSTable 写入与加载接口
- 验收标准：MemTable flush 到 SSTable 后可正确读取

**第 5 周：查询路径打通**
- 学习内容：读路径分层（MemTable + SSTable）
- 开发任务：实现 Get 查询链路，先查 MemTable，再查 SSTable
- 验收标准：同时覆盖内存与磁盘数据的查询正确性

**第 6 周：Compaction 合并**
- 学习内容：分层合并策略、重复键处理
- 开发任务：实现基础 Compaction 流程
- 验收标准：磁盘文件数量可控，旧数据正确被淘汰

### 9.2 阶段 B：Raft 共识协议（第 7–12 周）

**第 7 周：Raft 状态机框架**
- 学习内容：Leader/Follower/Candidate 状态转移
- 开发任务：实现 Raft 状态机骨架与超时机制
- 验收标准：单机多线程模拟选举流程

**第 8 周：日志复制**
- 学习内容：AppendEntries 原理与心跳机制
- 开发任务：实现日志同步与心跳
- 验收标准：Leader 写入后 follower 日志保持一致

**第 9 周：日志冲突处理**
- 学习内容：日志对齐与冲突回滚
- 开发任务：实现冲突条目回滚逻辑
- 验收标准：节点恢复后日志可自动对齐

**第 10 周：提交与一致性保证**
- 学习内容：Commit Index 推进与安全性
- 开发任务：实现提交逻辑
- 验收标准：多数派确认后才对外可见

**第 11 周：快照机制**
- 学习内容：Snapshot 保存与恢复
- 开发任务：实现快照生成与加载接口
- 验收标准：节点重启后可通过快照快速恢复

**第 12 周：Raft 测试与故障注入**
- 学习内容：分布式故障模拟方法
- 开发任务：实现故障注入脚本与测试场景
- 验收标准：Leader 崩溃后系统仍可完成选举

### 9.3 阶段 C：网络层与集成（第 13–16 周）

**第 13 周：RPC 通信框架**
- 学习内容：异步 IO、序列化协议
- 开发任务：实现基础 RPC 调用
- 验收标准：节点之间可完成心跳通信

**第 14 周：Raft 与存储层集成**
- 学习内容：状态机与存储引擎的绑定
- 开发任务：实现 Put/Get 请求经 Raft 提交后落盘
- 验收标准：多节点数据一致

**第 15 周：读写性能优化**
- 学习内容：批量写、读缓存策略
- 开发任务：引入批量写入与基础读缓存
- 验收标准：吞吐提升，延迟降低

**第 16 周：集群稳定性测试**
- 学习内容：系统性故障测试设计
- 开发任务：模拟断网、节点崩溃、重启
- 验收标准：系统保持强一致性

### 9.4 阶段 D：工程化与展示（第 17–20 周）

**第 17 周：代码结构与工程化整理**
- 学习内容：模块化设计与目录规范
- 开发任务：整理模块划分与构建脚本
- 验收标准：新开发者可快速理解结构

**第 18 周：性能压测报告**
- 学习内容：基准测试方法
- 开发任务：产出读写性能曲线与测试报告
- 验收标准：性能曲线清晰可复现

**第 19 周：一致性验证**
- 学习内容：正确性测试方法
- 开发任务：构建一致性验证脚本
- 验收标准：多次重复测试无一致性错误

**第 20 周：成果打包与演示**
- 学习内容：项目表达与演示技巧
- 开发任务：编写 Demo 流程与说明材料
- 验收标准：能完整展示项目核心价值

### 9.5 每周投入建议
- 建议每周 12–20 小时投入
- 若每周少于 10 小时，总周期可能延长至 6 个月以上
