# DistributedKV 项目学习手册

## 目录
- [1. 项目愿景](#1-项目愿景)
- [2. 核心架构：LSM-Tree 存储策略](#2-核心架构lsm-tree-存储策略)
    - [2.1 什么是 LSM-Tree？](#21-什么是-lsm-tree)
    - [2.2 为什么选择 LSM-Tree？](#22-为什么选择-lsm-tree)
- [3. 内存组件：MemTable 与跳表](#3-内存组件memtable-与跳表)
    - [3.1 MemTable 的作用](#31-memtable-的作用)
    - [3.2 为什么用跳表 (SkipList) 实现？](#32-为什么用跳表-skiplist-实现)
    - [3.3 跳表的基本原理](#33-跳表的基本原理)
- [4. 分布式共识：Raft 协议](#4-分布式共识raft-协议)
- [5. 现代 C++ 异步编程](#5-现代-c-异步编程)
- [6. 构建系统与 CMake](#6-构建系统与-cmake)
    - [6.1 CMake 是什么？](#61-cmake-是什么)
    - [6.2 本项目的构建现状](#62-本项目的构建现状)
    - [6.3 是否有比 CMake 更高级的？](#63-是否有比-cmake-更高级的)
    - [6.4 该用哪种构建系统？](#64-该用哪种构建系统)
- [7. 编码规范与文档化](#7-编码规范与文档化)
- [8. 学习路径建议](#8-学习路径建议)
- [9. 关键术语表](#9-关键术语表)
- [10. 项目计划（周级细化）](#10-项目计划周级细化)
    - [10.1 阶段 A：单机存储引擎（第 1–6 周）](#101-阶段-a单机存储引擎第-16-周)
    - [10.2 阶段 B：Raft 共识协议（第 7–12 周）](#102-阶段-braft-共识协议第-712-周)
    - [10.3 阶段 C：网络层与集成（第 13–16 周）](#103-阶段-c网络层与集成第-1316-周)
    - [10.4 阶段 D：工程化与展示（第 17–20 周）](#104-阶段-d工程化与展示第-1720-周)
    - [10.5 每周投入建议](#105-每周投入建议)

---

## 1. 项目愿景与分布式系统基础

### 1.1 什么是分布式系统？
简单来说，分布式系统就是**一群独立的计算机，通过网络相互通信，并向用户表现得像一台单一的计算机一样**。

**核心特征：**
- **网络通信**：节点之间不共享内存，只能通过消息传递。
- **并发性**：多个节点同时运行。
- **缺乏全局时钟**：很难确定事件发生的绝对先后顺序。
- **部分故障**：集群中的某些节点可能挂掉或断网，但整个系统必须继续运行。

**为什么我们要搞分布式 KV？**
单机存储总有上限（磁盘容量、处理能力）。通过分布式，我们可以实现：
- **可扩展性 (Scalability)**：加机器就能存更多数据。
- **容错性 (Fault Tolerance)**：一台机器坏了，数据不丢，服务不投降。

---

## 2. 核心架构：[LSM-Tree](#9-关键术语表) 存储策略

### 2.1 什么是 [LSM-Tree](#8-关键术语表)？
[LSM-Tree](#8-关键术语表) (Log-Structured Merge-Tree) 不是一种单一的数据结构，而是一种**存储策略**。它主张“所有写操作都先写内存，攒够了再批量顺序写磁盘”。

**深度解析：顺序写 vs 随机写**
*   **随机写 (Random Write)**：类似于在图书馆找书，如果你要找 10 本分布在不同楼层的书，你需要不停地跑动、坐电梯、翻找，大部分时间浪费在“寻找”上。传统 B+ Tree 索引的就地更新就是随机写。
*   **顺序写 (Sequential Write)**：类似于在纸上一行一行写字。你不需要翻页或跳跃，笔尖始终在移动。
*   **性能差异**：在机械硬盘（HDD）上，顺序写比随机写快近千倍；在固态硬盘（SSD）上，顺序写也能显著减少磨损并提升吞吐量。

[LSM-Tree](#8-关键术语表) 的核心技巧就是：**通过内存缓冲区和后台[合并 (Compaction)](#8-关键术语表)，将应用程序的“随机写”操作，在磁盘层面转化为“顺序写”操作。**

### 2.2 为什么选择 [LSM-Tree](#8-关键术语表)？
1. **极致的写入性能**：所有的写入都是追加操作（Append-only），利用了磁盘最擅长的顺序 I/O。
2. **适应现代硬件**：对 SSD 极其友好，减少了随机小块写入带来的 GC 压力。
3. **分层管理**：通过后台的 [Compaction（合并）](#8-关键术语表) 过程，逐步清理旧数据，保持数据的有序性。

**推荐阅读**：
建议阅读《数据密集型应用系统设计 (DDIA)》第三章 "Storage and Retrieval"，其中详细对比了 B-Tree 和 [LSM-Tree](#8-关键术语表) 的优劣：
- **[写入放大 (Write Amplification)](#8-关键术语表)**：[LSM-Tree](#8-关键术语表) 通常具有更低的写入放大，适合写密集型负载。
- **顺序 I/O**：即使在 SSD 上，顺序写也能减少擦写次数，延长设备寿命。

---

## 3. 内存组件：MemTable 与跳表

### 3.1 MemTable 的作用
MemTable 是数据进入数据库的第一站。它驻留在内存中，负责暂存最近写入的数据，并保持数据的**有序性**，以便支持快速的范围查询。

### 3.2 为什么用跳表 (SkipList) 实现？
1. **实现简单**：相比红黑树或 AVL 树，跳表的实现逻辑更清晰，代码量通常只有平衡树的 1/3。
2. **并发友好**：在多线程环境下，跳表的无锁化或细粒度锁实现比平衡树更高效。LevelDB 和 RocksDB 选择跳表作为 MemTable 的核心原因之一，就是因为它只需要简单的 CAS 操作就能支持无锁并发读写，而平衡树的旋转操作在并发下极难维护。
3. **性能稳定**：平均查询时间复杂度为 $O(\log n)$，与平衡树相当。

### 3.3 跳表的基本原理
跳表通过在普通链表之上建立“多层索引”来实现快速跳转。
- **层级 (Level)**：每个节点被随机分配一个高度。
- **查找**：从最高层开始，如果当前层的下一个节点比目标大，则下沉到低一层继续查找。

---

## 4. 分布式共识：[Raft](#8-关键术语表) 协议
[Raft](#8-关键术语表) 是目前工业界最流行的分布式一致性算法。它将复杂的问题分解为三个子问题：
1. **Leader 选举**：集群中始终有一个 Leader 负责处理所有客户端请求。
2. **日志复制**：Leader 将操作记录同步给 Follower，只有大多数节点确认后，数据才算“提交”。
3. **安全性**：通过[任期 (Term)](#8-关键术语表)和日志索引 (Index) 保证历史数据不被覆盖。

---

## 5. 现代 C++ 内存管理：智能指针与 RAII

### 5.1 什么是 RAII？
**RAII** (Resource Acquisition Is Initialization)，即“资源获取即初始化”。它是 C++ 语言中最核心的编程思想之一。

**核心逻辑：**
1. **获取资源即初始化**：在对象的**构造函数**中获取资源（如申请内存、打开文件、加锁）。
2. **释放资源即析构**：在对象的**析构函数**中释放资源。
3. **绑定生命周期**：将资源的生命周期与局部对象的生命周期绑定。只要对象被销毁（如离开作用域），资源就会自动释放。

**为什么它很伟大？**
- **防泄漏**：即使函数中间抛出异常或提前 `return`，析构函数也一定会被调用。
- **自动化**：程序员不再需要手动写 `delete`、`fclose()` 或 `unlock()`，减少了心智负担。

**本项目中的应用：**
- **智能指针**：`std::unique_ptr` 封装了裸指针的 `new/delete`。
- **文件流**：`std::ofstream` 离开作用域自动关闭文件。
- **并发锁**：`std::lock_guard` 离开作用域自动释放互斥锁（后续 Raft 实现中会大量使用）。

---

### 5.2 三大智能指针详解

#### 1. `std::unique_ptr`（独占所有权）
- **核心思想**：同一时间只能有一个指针拥有该对象的所有权。
- **特点**：
    - 不可拷贝，只能移动（`std::move`）。
    - 几乎没有性能开销（与裸指针性能一致）。
- **什么是“移动” (Move)？**
    - **通俗理解**：拷贝是“复印”，移动是“过户”。
    - **底层原理**：移动不会产生新的数据副本。它只是把原指针内部指向内存的地址“偷”过来，给新指针，然后把原指针置为空（nullptr）。
    - **为什么要移动？**：性能极高。比如一个管理 1GB 内存的对象，拷贝需要复制 1GB 数据，而移动只需要复制一个 8 字节的地址指针。
    - **语法**：使用 `std::move(ptr)` 将左值强制转换为右值引用，从而触发移动构造函数。
- **适用场景**：
    - **默认选择**：当你需要一个局部的、生命周期明确的对象时。
    - **容器管理**：如本项目的 `nodes_storage`，由 `SkipList` 独占所有节点的所有权。

#### 2. `std::shared_ptr`（共享所有权）
- **核心思想**：通过**引用计数**实现多个指针共享同一个对象。
- **缺点：循环引用（Circular Reference）**：
    - **为什么不得不互相引用？**
        - **父子关系**：在 GUI 框架中，父窗口拥有子按钮（`shared_ptr`），但子按钮有时需要回调父窗口的方法（如果也用 `shared_ptr`，就循环了）。
        - **双向链表**：前驱节点指向后继，后继也指向前驱。
        - **观察者模式**：被观察者（Subject）通知观察者，观察者（Observer）有时也需要取消订阅（反向引用）。
    - **后果**：它们的引用计数永远至少为 1，导致即便外部已经没有任何指针指向它们，它们也永远不会被销毁。这就是内存泄漏！

#### 3. `std::weak_ptr`（弱引用）
- **核心思想**：它是 `shared_ptr` 的“观察者”。它指向对象，但**不增加引用计数**。
- **为什么使用前必须调用 `lock()`？**
    - **安全性保证**：`weak_ptr` 不拥有对象，它指向的对象可能随时被其他线程释放。
    - **原子操作**：`lock()` 是一个原子操作。它会检查对象是否还活着：
        - 如果还活着，它会把引用计数 **+1**，并返回一个临时的 `shared_ptr`。只要这个 `shared_ptr` 还在，对象就绝对不会在你处理逻辑时被删掉。
        - 如果对象已经没了，它返回一个空的 `shared_ptr`。
    - **如果不 lock 而是直接使用会怎样？**：你可能在第一行代码判断它还活着，但在第二行真正访问成员时，对象刚好被删了，程序会直接崩溃（段错误）。
- **如何配合使用？**
    - **打破循环**：在双向关系中，一方持强引用（`shared_ptr`），另一方持弱引用（`weak_ptr`）。
    - **代码示例**：
        ```cpp
        std::weak_ptr<int> wp = sp; // sp 是 shared_ptr
        // wp.use_count() 不会增加
        if (auto locked_sp = wp.lock()) {
            // 此时 locked_sp 是一个新的 shared_ptr，计数 +1
            // 即使外部的 sp 被销毁，locked_sp 也能保证对象在这里是安全的
            std::cout << *locked_sp << std::endl;
        } // 函数结束，locked_sp 销毁，计数 -1
        ```

### 5.3 决策指南：该选哪种？

| 场景 | 推荐方案 | 理由 |
| :--- | :--- | :--- |
| **大部分情况** | `std::unique_ptr` | 性能最优，职责最清晰。 |
| **需要多个拥有者** | `std::shared_ptr` | 自动处理复杂的生命周期共享。 |
| **打破循环引用** | `std::weak_ptr` | 防止 A 引用 B，B 又引用 A 导致的永久不释放。 |
| **底层性能敏感/算法实现** | 裸指针 (`T*`) | 仅用于**观察**（不拥有所有权），如跳表节点间的 `forward` 链接。 |

---

## 6. 构建系统与 CMake

### 6.1 CMake 是什么？
CMake 是一套跨平台的构建配置系统，它通过读取 `CMakeLists.txt` 来生成不同平台的构建文件（如 Ninja、Unix Makefiles、Visual Studio 工程）。核心思想是用“目标”来表达库和可执行文件，以及它们之间的依赖、编译选项和链接关系。

### 6.2 本项目的构建现状
当前仓库中未发现 `CMakeLists.txt` 或其他构建系统配置文件，因此项目尚未确定具体的构建方案。

### 6.3 是否有比 CMake 更高级的？
从行业现状看，CMake 仍是 C++ 领域最主流的构建系统之一，尤其在跨平台库、系统级软件和开源项目中依然占主导。与此同时，Bazel、Meson、XMake 等更现代的方案在部分团队中增长，但并没有形成对 CMake 的全面替代，它们只是不同的工程取舍。

### 6.4 该用哪种构建系统？
建议优先选择 CMake 作为本项目的构建系统。理由是生态成熟、工具链支持广、与主流 IDE 和 CI 集成简单，且学习资料丰富。等项目规模显著扩大、需要更强的缓存与大规模构建能力时，再评估 Bazel 或其他方案会更稳妥。

---
 
 ## 7. 编码规范与文档化
 
 ### 7.1 Doxygen 注释规范
 本项目采用 Doxygen 风格的文档注释，以便于 IDE 智能提示和自动生成 API 文档。
 - **格式**：使用 `/** ... */` 开头。
 - **常用标签**：
   - `@brief`：简要描述功能。
   - `@tparam`：描述模板参数。
   - `@param`：描述函数参数。
   - `@return`：描述返回值。
 
 ---
 
 ## 8. 学习路径建议
1. **第一阶段：单机存储核心**
   - 实现一个线程安全的跳表（SkipList）。
   - 学习如何使用 `mmap` 或 `fwrite` 实现 [WAL](#8-关键术语表)。
   - 实现简单的 [SSTable](#8-关键术语表) 读取与查询。
2. **第二阶段：Raft 算法实现**
   - 编写状态机逻辑。
   - 模拟节点间的 RPC 通信（可以先在单机模拟多个线程代表不同节点）。
3. **第三阶段：网络与集成**
   - 学习 C++ 协程库（如 `asio` 或自研简单的协程调度器）。
   - 将 Raft 与 LSM-Tree 结合，实现真正的分布式 KV 存储。

---
 
 ## 9. 关键术语表
- **LSM-Tree (Log-Structured Merge-Tree)**：一种将随机写转换为顺序写的存储策略，通过内存 MemTable 和磁盘 SSTable 的多层合并实现。
- **Raft**：一种易于理解的分布式共识算法，负责在集群中达成一致性。
- **Term (任期)**：Raft 中的逻辑时间单位。
- **Commit Index**：已知已提交的最高日志索引。
- **SSTable (Sorted String Table)**：持久化在磁盘上的有序键值对文件。
- **Write-Ahead Log (WAL)**：用于崩溃恢复的顺序日志文件。
- **Compaction**：后台线程定期合并多个小文件，删除冗余数据。
- **Write Amplification (写入放大)**：实际写入磁盘的数据量与用户请求写入的数据量之比。在 LSM-Tree 中，由于数据需要不断在各层之间进行合并重写，会产生较大的写入放大。
- **Read Amplification (读取放大)**：为了找到一个 Key，需要查询多个文件（MemTable + 各层 SSTable）而导致的多次 I/O。
- **Space Amplification (空间放大)**：由于保留了旧版本数据或被标记删除的数据，磁盘实际占用空间大于有效数据量。
 
 ---
 
 ## 10. 项目计划（周级细化）
 
 ### 10.1 阶段 A：单机存储引擎（第 1–6 周）

**第 1 周：LSM-Tree 与 MemTable 基础**

本周目标：搭建项目骨架，理解 LSM-Tree 核心思想，并完成跳表（SkipList）的基础结构设计与空跑测试。

*   **任务一：理论预热与环境准备（已完成）**
    *   **复习**：回顾本文第 2 章与第 3 章，深入理解 LSM-Tree 的顺序写优势及跳表的选型理由。
    *   **实战**：检查 C++ 编译器（GCC/Clang）与 CMake 环境。
 
 *   **任务二：项目工程化搭建（已完成）**
    *   **实战**：创建项目目录结构：
         *   `src/`：源代码
         *   `include/`：头文件
         *   `tests/`：测试代码
         *   `docs/`：文档
    *   **实战**：编写根目录 `CMakeLists.txt`，配置基础编译选项（建议开启 `-std=c++17` 或更高，以及 `-Wall -g`）。
 
 *   **任务三：跳表核心数据结构设计（已完成）**
    *   **代码**：定义 `SkipList` 模板类（支持泛型 Key 和 Value）。
    *   **代码**：设计内部 `Node` 结构体：
         *   成员：`Key`, `Value`
         *   成员：`forward` 指针数组（用于指向不同层级的下一个节点）
    *   **代码**：理解并实现“最大层数”与“概率因子”常量的定义。

*   **任务四：随机层数生成与辅助函数（已完成）**
    *   **理论**：理解跳表节点高度的随机生成机制（几何分布）。
    *   **代码**：实现 `random_level()` 函数，确保生成的层数符合概率分布。
    *   **代码**：实现构造函数与析构函数，注意内存管理（使用智能指针管理节点）。

*   **任务五：核心接口声明 (API Design) (已完成)**
    *   **代码**：在头文件中完成核心功能的接口声明（暂不实现具体逻辑）：
        *   `insert(key, value)`
        *   `search(key)`
        *   `remove(key)` (注：LSM 中通常标记删除，但基础跳表可先实现物理删除)
    *   **代码**：编写一个简单的 `main.cpp`，实例化 `SkipList` 对象并调用上述空接口，确保编译通过。

*   **任务六：单元测试框架接入**
    *   **实战**：引入 Google Test (GTest) 库（推荐通过 CMake FetchContent 自动下载，或手动配置）。
    *   **实战**：编写第一个“冒烟测试”：创建一个跳表对象，断言其初始化状态（如当前层级为 0，头节点存在等）。
    *   **验收**：运行 `ctest` 或执行测试二进制文件，看到绿色的 `PASSED`。

**第 2 周：跳表实现与稳定性测试**
- 学习内容：随机层级生成、边界条件处理、时间复杂度
- 开发任务：实现跳表插入/查找/删除逻辑
- 验收标准：支持 1 万条键值对插入与随机查找，结果正确

**第 3 周：WAL 预写日志**
- 学习内容：顺序写、崩溃恢复基本概念
- 开发任务：实现 WAL 写入与重放逻辑，确保写入先落盘
- 验收标准：模拟进程崩溃后能重建 MemTable

**第 4 周：SSTable 文件格式**
- 学习内容：有序文件结构、索引与数据块布局
- 开发任务：实现 SSTable 写入与加载接口
- 验收标准：MemTable flush 到 SSTable 后可正确读取

**第 5 周：查询路径打通**
- 学习内容：读路径分层（MemTable + SSTable）
- 开发任务：实现 Get 查询链路，先查 MemTable，再查 SSTable
- 验收标准：同时覆盖内存与磁盘数据的查询正确性

**第 6 周：Compaction 合并**
- 学习内容：分层合并策略、重复键处理
- 开发任务：实现基础 Compaction 流程
- 验收标准：磁盘文件数量可控，旧数据正确被淘汰

### 10.2 阶段 B：Raft 共识协议（第 7–12 周）

**第 7 周：Raft 状态机框架**
- 学习内容：Leader/Follower/Candidate 状态转移
- 开发任务：实现 Raft 状态机骨架与超时机制
- 验收标准：单机多线程模拟选举流程

**第 8 周：日志复制**
- 学习内容：AppendEntries 原理与心跳机制
- 开发任务：实现日志同步与心跳
- 验收标准：Leader 写入后 follower 日志保持一致

**第 9 周：日志冲突处理**
- 学习内容：日志对齐与冲突回滚
- 开发任务：实现冲突条目回滚逻辑
- 验收标准：节点恢复后日志可自动对齐

**第 10 周：提交与一致性保证**
- 学习内容：Commit Index 推进与安全性
- 开发任务：实现提交逻辑
- 验收标准：多数派确认后才对外可见

**第 11 周：快照机制**
- 学习内容：Snapshot 保存与恢复
- 开发任务：实现快照生成与加载接口
- 验收标准：节点重启后可通过快照快速恢复

**第 12 周：Raft 测试与故障注入**
- 学习内容：分布式故障模拟方法
- 开发任务：实现故障注入脚本与测试场景
- 验收标准：Leader 崩溃后系统仍可完成选举

### 10.3 阶段 C：网络层与集成（第 13–16 周）

**第 13 周：RPC 通信框架**
- 学习内容：异步 IO、序列化协议
- 开发任务：实现基础 RPC 调用
- 验收标准：节点之间可完成心跳通信

**第 14 周：Raft 与存储层集成**
- 学习内容：状态机与存储引擎的绑定
- 开发任务：实现 Put/Get 请求经 Raft 提交后落盘
- 验收标准：多节点数据一致

**第 15 周：读写性能优化**
- 学习内容：批量写、读缓存策略
- 开发任务：引入批量写入与基础读缓存
- 验收标准：吞吐提升，延迟降低

**第 16 周：集群稳定性测试**
- 学习内容：系统性故障测试设计
- 开发任务：模拟断网、节点崩溃、重启
- 验收标准：系统保持强一致性

### 10.4 阶段 D：工程化与展示（第 17–20 周）

**第 17 周：代码结构与工程化整理**
- 学习内容：模块化设计与目录规范
- 开发任务：整理模块划分与构建脚本
- 验收标准：新开发者可快速理解结构

**第 18 周：性能压测报告**
- 学习内容：基准测试方法
- 开发任务：产出读写性能曲线与测试报告
- 验收标准：性能曲线清晰可复现

**第 19 周：一致性验证**
- 学习内容：正确性测试方法
- 开发任务：构建一致性验证脚本
- 验收标准：多次重复测试无一致性错误

**第 20 周：成果打包与演示**
- 学习内容：项目表达与演示技巧
- 开发任务：编写 Demo 流程与说明材料
- 验收标准：能完整展示项目核心价值

### 10.5 每周投入建议
- 建议每周 12–20 小时投入
- 若每周少于 10 小时，总周期可能延长至 6 个月以上
